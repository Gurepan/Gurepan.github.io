---
layout:     post
title:      从一个角度看分布式事务的各种实现
subtitle:   
date:       2021-01-04
author:     Gure
header-img: img/2020-11-05-start/bg.jpg
catalog: true
tags:
    - 分布式
---



## 事务的通用实现

事务本身拥有ACID特性，也就是以下四个：

- 原子性-atomicity
- 一致性-consistency
- 隔离性-isolation
- 持久性-durability

在我们平时的语境以及运用场景中，由于各种落盘操作，持久性这个特性更多是在操作系统层面被提及的。剩余的3个特性，原子性，一致性，隔离性，则是我们实际开发中考虑较多的场景。尽管在分布式的语境环境中，对这三个特性的要求有所放宽，但是实际上可以发现，无论是本地事务还是分布式事务，对处理以上特性的思路其实是一样。或者说，他们都抽象出了相同的待解决问题：

- 原子提交（Atomic Commit）讨论如何将一批操作最终一起完成或者一起失败
- 并发控制（Concurrency Control） 讨论一个事务在尽可能少的向其他服务暴露中间过程条件下可以达到的并发量

对于如何实现原子提交，古往今来的做法都是一致的：先写日志再操作，日志的操作必须幂等。中途若是有中断，可以选择恢复后利用发起重试直到事务成功（Commit），也可以根据日志记录来回滚（Rollback）。这些日志有不同的实现方案，有数据库层面的（redo log），有中间件层面的（AT模式的undo log），有业务层面的（本地事务表），还有看着并不像日志的（消息队列的message）。

对于如何做并发控制，解决方案就有几个可以选择了，有最经典的基于锁方案的如数据库读写锁，有基于乐观并发控制的乐观锁，也有基于分区概念的分区无锁单线程处理（actor）。由于分区无锁实在称不上主流，对于程序开发难度也太高，因此本文不会提及它。除此之外，假设我们把乐观锁也看错是锁的一种的话，我们可以得出一个结论：事务的并发控制基本上都是通过锁实现的。

**本文也将从日志和锁的角度，尝试解释我们常见的分布式事务是怎么实现的。**

## 数据库本地事务

数据库事务不算分布式事务，我们在此只是用其热个身而已。

首先从日志角度解释其如何做到原子提交：熟悉数据库事务的同学都清楚，数据库可以各种中间状态恢复至起初或者完成状态，依赖的是其redo log 以及伴生的undo log。redo log的commit意味着事务的完成，即使真正的数据因为各种原因没有保存下来，也可以根据redo log恢复；undo log则记录了数据的最初状态，若未提交时发生错误可以依据此恢复到最初状态。通过这两个日志，整个事务将达到最终或者最初状态，不会停留在中间状态，实现原子提交。

其次从锁的角度解释其如何做到并发控制：数据库层面的两把锁，共享锁和排他锁。并发隔离级别最低的READ UNCOMMITTED只在写时加了排他锁，并发时暴露中间状态最多，并发程度也最高；RC,RR在读时使用了read view来实现mvcc，但是写时依旧使用排他锁，并发程度算中等。序列化的隔离级别在读时加了共享锁（范围查找还有范围锁），写时加了排他锁，此时读写时候就会相互阻塞，并发程度最低，但是可以认为不会暴露任何中间状态。

我们可以得出结论，数据库用日志和锁实现了事务的原子性，一致性，隔离性，知晓这个思路，我们也可以自行实现本地事务。

## 分布式事务实现时日志和锁的应用

#### 2PC

如果从日志和锁的角度来看一个最简版本2PC协议的话，可以发现里面的很多问题：首先，尽管分布式事务中的小事务依赖于数据库日志完成了原子提交，通信正常的情况下在Prepare结算时候可以判断Commit还是Rollback来达到All-or-Noting的原子特性，但是事务协调器（TC）本身并没有为这个过程记录log，最极端的情况下是事务协调者在发送完一个或者多个Commit消息之后崩溃，服务恢复以后就无法处理数据的中间状态，持有的锁也不会被释放，业务将发生阻塞。因此改良的2PC协议一般都是从记录操作log以及恢复操作log的思路入手，有的更进一步，做好状态分离或者状态转移来实现高可用。其次的一个问题，2PC的锁机制依赖于小事务的锁机制，其隔离的精髓在于在Prepare阶段累积锁，在Commit阶段统一释放。这个机制十分依赖于底层锁。如果底层数据库隔离级别是序列化时候，这个方案不会有任何问题，但是如果底层使用了MVCC的话，在部分Commit时候就会出现多个数据源数据不一致的问题。出现这个问题的原因是因为，事务协调器上没有一个统一的锁对象。

seata的AT模式在日志和锁这两方面对此做了改良。

#### AT

AT对于日志的改良有两方面。一是事务协调器（TC）将协调操作日志进行了落盘，这样不仅有利于故障恢复更有利于高可用；二是放弃了使用数据库本身log机制，并自己实现了undo log。于此同时本地事务完成即可commit无需等待所有服务的响应。这样有利于本地资源及时释放避免堵塞，提高吞吐量。通过这两个优化，在解决原子提交的同时，也尽可能避免了阻塞，提高了可用性。

但是这样的操作使分布式事务无法使用数据库提供的锁机制。为了并发控制下的隔离性，AT设计了全局锁。接下来的思路就和本地事务的隔离性实现思路是一样的了。值得一提的是，AT默认的隔离级别是READ UNCOMMITTED，也就是只在写的时候采用了排他锁。

AT作为一个大而全的方案的确提供了很好的解决思路，但是人们还是在不同场景下探究更改灵活的解决方案。

#### 对日志和锁和锁的思考

**日志，何必是日志？**我们为什么要对每一个操作，每一个数据变化记录日志？假设中间操作是幂等的，很多业务完全不用记录中间操作，直接回发整个流程即可，若要回归，大可不必恢复所有数据。简简单单做一个业务上的取消操作即可。以此推论，要是业务契合，只需要记录业务起点日志即可。甚至可以继续化简，只需要一个标志位，一条消息……只要业务场景合适，日志，何必是日志？

**锁，何必要锁？**很多业务场景对于暴露数据的中间状态并不关心，这种形势下对于一条数据控制并发不能简简单单一锁了之。交由业务决定可以做到更细粒度的控制并发，提高性能。

将日志和锁的定义力度交由业务决定，就可以衍生出很多形式。

#### 本地事务表，TCC以及SAGA

用以上方法论来分析其他事务方案：

- 本地事务表，顾名思义，将分布式事务日志记录在本地表里面，以此来保证最终一起成功或者一起失败。对锁没有实现，也就是不存在隔离性，需要自行实现。

- TCC，通过框架已经记录了日志。隔离性由try阶段对资源的锁定部分实现（并不完整）。

- SAGA，拈花飞叶无不可是日志，对锁没有实现，需要自行实现。

其他的方案，比方说利用消息队列什么的，全部都可以带入这个框架中分析。同时自己也可以通过对这两个方面的把控，根据自己的业务，设计出自己的分布式事务结构来。

完结。

PS：这文章是我在面了很多面试官以后实在被他们问烦了写的，感觉很多面试官也只是局限在他们用的那几个框架内，一旦发现我之前用的不是那些，交流起来就很费劲了，因此这也是我的怨念吧（毕竟我之前公司的确没用那些框架啊喂！）。其实互联网领域的分布式问题应该算毕竟经典，研究地都毕竟透了，提高性能就是加机器。提高可用性也是加机器。有状态服务还要注意状态复制或者状态转移，必要时使用分布式一致性协议，无状态服务注意服务协调机制。另外就是分布式事务，注意原子提交以及并发控制。再加上相关的工具如RPC，服务发现，共享数据等。还是希望在讨论问题的时候，大家不要太浮于表面为好。