---
layout:     post
title:      函数调用的机械化代换（1）
subtitle:   如何将递归调用转化为迭代
date:       2020-11-06
author:     Gure
header-img: img/sicp.jpg
catalog: true
tags:
    - 语言的魔法
---

这篇文章其实是一个引子，用来引起我对语言，以及语言所描述的东西体现的风格的思考。

这次我们讨论的是递归和迭代的转换，还是从一个小例子说起：二叉树的前序，中序，后续遍历，从中希望可以推导出一种通用的方法。

## 二叉树的构造

二叉树结构还是很简单的，这里用`python`来举例子：

```python
class Node:
   left = None
   right = None
   data = None

   def __init__(self, data, left=None, right=None):
       self.data = data
       self.left = left
       self.right = right
```

构建的话只需要这样写：

```python
tree = Node(7,
            Node(5,
                 Node(2,
                      Node(1),
                      Node(4,
                           Node(3))),
                 Node(6)),
            Node(9,
                 Node(8),
                 Node(11,
                      Node(10),
                      Node(12,
                           None,
                           Node(13)))))
```

这样的写法看似挺突兀的，其实习惯了就发现，在使用代码构建这颗这棵树的时候，顺路已经把整颗树的结构给描述出来了。在这里我们相当于**混淆了数据和代码的界限，代码即数据**。有一种声明式语言的特点。但是这篇文章重点不在这里，因此暂且略过，来看它的前序，中序，后续遍历写法。

## 深度遍历的递归写法

#### 前序遍历

前序遍历的顺序是从根结点 ---> 左子树 ---> 右子树，用伪代码来描述就是：

- 使用`pred`消费根结点
- 如果左子树不为空，则继续遍历左子树
- 如果右子树不为空，则继续遍历右子树

写成代码如下：

```python
def rec_tree_front(tree: Node, pred):
    pred(tree.data)
    if tree.left:
        rec_tree_front(tree.left, pred)
    if tree.right:
        rec_tree_front(tree.right, pred)
```

#### 中序遍历

中序遍历的顺序是从左子树---> 根结点 ---> 右子树，用伪代码来描述就是：

- 如果左子树不为空，则继续遍历左子树

- 使用`pred`消费根结点
- 如果右子树不为空，则继续遍历右子树

写成代码如下：

```python
def rec_tree_mid(tree: Node, pred):
    if tree.left:
        rec_tree_mid(tree.left, pred)
    pred(tree.data)
    if tree.right:
        rec_tree_mid(tree.right, pred)
```

#### 后续遍历

后序遍历的顺序是从左子树 ---> 右子树 ---> 根结点，用伪代码来描述就是：

- 如果左子树不为空，则继续遍历左子树
- 如果右子树不为空，则继续遍历右子树

- 使用`pred`消费根结点

写成代码如下：

```python
def rec_tree_post(tree: Node, pred):
    if tree.left:
        rec_tree_post(tree.left, pred)
    if tree.right:
        rec_tree_post(tree.right, pred)
    pred(tree.data)
```

#### 小结

递归写法的遍历大都数人还是都可以很直观的写出来的，代码也很简单，基本上就是把对应的定义给翻译了一遍，做到了**代码即描述**。有些人不喜欢在实际代码中使用递归，很大原因是怕调用栈对最大递归深度的限制，以及对时间，空间复杂度的担心。但是我觉得，要是最大递归深度的限制有所担心的话，以现在对调用栈的规划，要是爆栈很大程度上都是代码写的不合理，要是有栈限制一下深度还好，要是改成循环了说不定就是一个无限循环或者是执行用了超多资源的代码了……而且空间复杂度也有栈帮忙限制着。至于时间复杂度，对于一般的递归来说问题并不大，`O（n）`的消耗和循环等价，至于像`fibonacci`那种复杂度爆表的递归，也有办法将其改造成线性递归或者使用缓存存储中间结果。最重要的是，递归是一种对于人类思维理解友好的写法，可以让人从整体的角度理解要做的事情而不是从细节出发猜测一段代码想要做什么。对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。

## 深度遍历的非递归写法

尽管在上面我说了一般情况下我推荐使用递归写法，但是这篇文章还是要来探讨一下非递归写法的。我随意在网上搜了搜，发现对于非递归写法，各路大神花样还是挺多的，有单栈的，双栈的，还有用哈希的。看了一圈我总结下来，有一点是共通的，就是很难懂，前序遍历，中序遍历还好，后续遍历是真的不容易懂。但是我们今天讨(zhuang)论(bi)的话题是`函数调用的机械化代换`，肯定不会让读者尝试去理解这么复杂的东西了。`机械化代换`顾名思义，就是读者把自己当作一台计算机，不需要考虑步骤的意义，不需要考虑最后的结果，按照给定的步骤（指令），一步步执行就可以完成递归和非递归的转换，至于转化出来的结果是怎么样的，可读性怎么样，这个管他呢，你现在是计算机，不是人。

递归是使用函数调用实现的。我们要做机械化演算当然要知道机器到底是怎么算的。函数调用在X86架构上执行代码如下（简化版）：

```assembly
sub $需要的参数的空间 %rsp
mov ...#填充参数
push %rip+返回地址
push %rbp
mov %rsp %rbp
#借此调用另外的函数，类似jmp
```

这段话做的事情如下：

- 在线性地址空间上开辟一块空间做栈帧，因为栈一般在地址空间高位向低位延申，所以这里用`sub`，`rsp`是64位机上的栈寄存器。
- 将入参填充到一块存储区域，这里的存储区域可以是内存也可以是寄存器，为了方便理解，大家就理解成填充到栈帧上好了。
- 将执行完这个调用的下一步动作压入栈中。
- 将现在执行栈的栈基址`rbp`压入栈中。此时，这个函数调用的现场已经保存好了。
- 将现在的栈地址赋值给栈基址，这样就相当于新的栈帧初始化好了。
- 借助类似于`jmp`的指令（相当于`C`里面的`goto`）跳转下一条指令地址（相当于给`pc`寄存器赋值）

这样就成功调用了函数。

函数返回时（我刻意没有用`leave`和`ret`指令，因为这几条指令已经可以描述了）：

```assembly
mov %rbp %rsp
pop %rbp
pop %rip
```

其实这几条指令可以看出来，是刚刚函数调用指令的反操作。意义也是和上面反过来。应该很容易看懂，就是撤销了栈帧，恢复了之前环境的地址。这里不多解释了，有兴趣的可以用`gcc -S`编译一个含有函数调用的C文件看看。

看完了计算机的执行过程，现在轮到我们自己来扮演这样一台计算机来做机械化代换了。于是我们依葫芦画瓢，我们自己也应该有个栈来存放调用过程，应该也有个`pc`来存放执行的位置。由于我们现在是递归，入参格式都是一样的，所以不需要将其存放在栈上，直接提取出来作为全局变量传参时候覆盖就好了（这里是为了节约空间，防止有人对空间占用耿耿于怀，要用的局部变量还是要存在栈上的）。这样由我们来作为计算机，将要执行的步骤记录下来，就是一份生成好的，转化好的，非递归写法程序了。

现在我们用这个思路试试：

```python
def rec_tree_front(tree: Node, pred):
    pred(tree.data)  #0
    if tree.left:
        rec_tree_front(tree.left, pred)  #1
    if tree.right:
        rec_tree_front(tree.right, pred) #2
```

上面分析可以得到，一共有两个入参，`tree`和`pred`，同时`tree`在递归时候作为局部变量发生了变化，`pred`不变。因此我们只用保存`tree`的值和此层函数运行状态就好了，如代码所适，里面有#0，#1，#2状态，另外也隐含了一个#3状态作为调用返回状态。 如果我们令`pc`状态表示为`row`，`row`就是里面的#0，#1，#2状态，栈为`s`，调用则为：

```python
s.append((tree, row + 1)) #将本层函数局部变量和pc+1保存下来
tree = tree.left #赋值要进入的函数入参
row = 0 #进入内层函数，指向内层函数首行
```

返回则是：

```python
(tree, row) = s.pop()#既返回了调用层函数局部变量，又返回了调用层函数下一步骤
```

现在，我们有了两条规则：

- 函数调用==手写压栈代码
- 调用返回（`return`语句，没有的话就是隐藏到最后了）==`(tree, row) = s.pop()`

这两条规则以及可以代换掉一部分代码了。现在还差最后一步，身为一台机器，一台状态机，我们需要用`pc`（这里是`row`）来指示我们下一步要执行的语句以及在**图灵完备**下的停机。我很直接的用了`while`+`if`来判断要执行的指令，当然也可以用`switch-case`或者其他策略来判断跳转，同时指定栈为空时候停机。

通过提取变量，定义`row`，创建自己的栈，使用代码替换函数调用和返回，用状态机管理步骤这几个通用流程之后，代码就可以被转化完成了。在这个步骤中，不需要关心这个代码究竟做了什么，是什么复杂的逻辑。用这个思路就可以代换成功。

我在这里贴一段转化后的代码：

```python
def cmd_tree_front(trees: Node, pred):
    s: [Node] = []
    row = 0
    while True:
        if row == 0:
            pred(trees.data)
            row += 1
        if row == 1:
            if trees.left:
                s.append((trees, row + 1))
                trees = trees.left
                row = 0
                continue
            else:
                row += 1
        if row == 2:
            if trees.right:
                s.append((trees, row + 1))
                trees = trees.right
                row = 0
                continue
            else:
                row += 1
        if row == 3:
            if not s:
                break
            (trees, row) = s.pop()
```

顺路贴一个后续遍历的转化代码，格式都差不多：

```python
def cmd_tree_post(trees: Node, pred):
    s: [Node] = []
    row = 0
    while True:
        if row == 0:
            if trees.left:
                s.append((trees, row + 1))
                trees = trees.left
                row = 0
                continue
            else:
                row += 1
        if row == 1:
            if trees.right:
                s.append((trees, row + 1))
                trees = trees.right
                row = 0
                continue
            else:
                row += 1
        if row == 2:
            pred(trees.data)
            row += 1
        if row == 3:
            if not s:
                break
            (trees, row) = s.pop()
```

大家可以拿去对比之前大家学习的非递归写法来做个对比。

## 后记

看到这里，恭喜大家，也恭喜我自己。我花了3个多小时，读者也看了近3000字，终于又学会了一个“并没有什么用”的小知识，哈哈。若是大家还有兴趣的话，也许会发现，这样的写法事实上还是有毛病的。第一不能算完整保存指令地址，每次都要循环判断。第二读者要自己动手的地方太多了，人毕竟不是机器很容易出错。因此这样的写法实用性不是很高。不过我说了这一篇文章是个引子，我接下来还是会给（编）出优化的方法展示（忽悠）大家看的。